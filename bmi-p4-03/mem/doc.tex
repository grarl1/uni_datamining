\documentclass[spanish]{assignment}

% Title page
\title{Búsqueda y Minería de Información}
\subtitle{Práctica 4 - Sistemas de Recomendación y Análisis de Redes Sociales}
\author{Enrique Cabrerizo Fernández\\ Guillermo Ruiz Álvarez}
\date{\today}
\university{Universidad Autónoma de Madrid}

\begin{document}
	\makepre
	\section{Sistemas de recomendación}
	En esta sección se describirá la estructura y el diseño de los sistemas de recomendación implementados en esta práctica.
	Se han desarrollado dos sistemas de recomendación:
	\begin{itemize}
		\item Basados en contenido, utilizando Rocchio como método de recomendación.
		\item Basados en filtrado colaborativo por usuario, utilizando KNN como método de recomendación. 
	\end{itemize}
	En ambos sistemas se utiliza un \texttt{Min-Heap} para ordenar los resultados.
	
	\subsection{Estructura de datos utilizada}
	Para almacenar y operar los datos se han utilizado dos librerías externas.
	\begin{itemize}
		\item Se ha utilizado la clase \texttt{HashBasedTable} de \texttt{Guava} para el almacenamiento
		de datos en tablas. Estas tablas son equivalentes a una tabla hash con dos claves en lugar de una.
		\item Se ha utilizado la clase \texttt{SparseDoubleMatrix2D} de \texttt{Colt} para operar con los datos utilizando matrices dispersas. 
		
		Dado que estas matrices tienen un tamaño limitado, se han creado clases que a parte de almacenar los datos en la matriz tienen estructuras de datos (arrays y tablas hash) para poder obtener un identificador a partir de una fila (o columna) y una fila (o columna) a partir de un identificador.
	\end{itemize}
	
	\subsection{Modelo de ponderación de las etiquetas}
	El modelo que se ha utilizado para la ponderación de las etiquetas es el siguiente:
	\begin{itemize}
		\item Se han tomado los identificadores de las películas como identificadores de documentos.
		\item Se han tomado los identificadores de las etiquetas como identificadores de términos.
		\item Se han tomado los pesos de las etiquetas como la frecuencia de los términos en los respectivos documentos.
	\end{itemize}
	Una vez hecho esto, se ha creado una tabla donde el elemento $(i,j)$ es el $tf-idf(t_j, m_i)$, donde $t_j, m_i$ representa un término y una película, respectivamente.
	
	\newpage
	\subsection{Recomendación basada en contenido.}
	Para implementar el sistema de recomendación basada en contenido se ha creado una clase \texttt{ContentBased} que utiliza:
	\begin{itemize}
		\item La clase \texttt{MovieRatingData} para cargar la matriz de ratings, en la que las filas representan usuarios, las columnas películas, y los valores los correspondientes ratings.
		\item La clase \texttt{MovieContentData} para cargar la matriz de contenido, en la que las filas representan películas, las columnas etiquetas, y los valores el $tf-idf$ de cada película y etiqueta. 
		\item La clase \texttt{RocchioSimilarity} utilizada para generar y almacenar los valores de ranking de las peliculas aún no valoradas por un usuario.
	\end{itemize}
	
	\subsubsection{Sistema de recomendación - Rocchio}
	Dada una fila de la matriz de ratings, se calcula el centroide de un usuario realizando el siguiente producto:
	$$centroide(u) = c^u = \frac{1}{|u|}\vec{u}C$$
	donde $|u|$ es el número de películas valoradas por el usuario, $\vec{u}$ es la fila de la matriz de ratings correspondiente al usuario $u$ y $C$ es la matriz de contenido donde las películas están representadas por filas.
	
	Una vez obtenido el centroide, se realiza el coseno del mismo con todas las filas de la matriz de contenido que no hayan sido valoradas por el usuario, aplicando la fórmula:
	$$cos(c^u, m_i) = \frac{c^u\cdot m_i}{\sqrt{c^u\cdot c^u\times m_i\cdot m_i}}$$
	
	donde $m_i$ representa el vector fila de la matriz de contenido correspondiente a la película con índice $i$.
	
	\subsection{Recomendación basada en filtrado colaborativo.}
	Para implementar el sistema de recomendación basada en contenido se ha creado una clase \texttt{CollaborativeUserBased} que utiliza:
	\begin{itemize}
		\item La clase \texttt{MovieRatingData} para cargar la matriz de ratings, en la que las filas representan usuarios, las columnas películas, y los valores los correspondientes ratings.
		\item La clase \texttt{KNNSimilarity} utilizada para generar y almacenar los valores de rating de las peliculas aún no valoradas por un usuario.
	\end{itemize}
	
	\subsubsection{Sistema de recomendación - KNN}
	Se han realizado dos implementaciones del cálculo de similitudes para este método de recomendación.
	\begin{itemize}
		\item El primero y más sencillo toma una fila correspondiente a un usuario de la matriz de ratings y calcula el coseno de la misma con todas las demás, guardándo los valores en una tabla hash. Tras ello, introduce todos los vecinos con sus respectivos valores de similitud en un min-heap de tamaño $k$ fijo, de manera que al final se tiene un conjunto con los $k$ vecinos más cercanos al usuario escogido. Finalmente, para cada película no valorada por el usuario, se calcula el rating con los $k$ vecinos obtenidos.
		
		\item El segundo realiza la operación siguiente:
		$$S = R\cdot R^T$$
		Donde $R$ es la matriz de ratings, $R^T$ su traspuesta y $S$ la matriz simétrica resultante, en la que el elemento $(i,j)$ es el valor del producto escalar del vector del usuario $i$ con el usuario $j$.
		Tras ello se obtiene la matriz de similitudes como sigue, con $i<j$ (ya que la matriz es simétrica):
		$$S_{ij} = \frac{S_{ij}}{\sqrt{S_{ii}\times S_{jj}}}$$
		Que es equivalente a
		$$S_{ij} = \frac{u_i\cdot u_j}{\sqrt{u_i\cdot u_i \times u_j \cdot u_j}} = cos(u_i, u_j)$$
		
		Este método tarda un poco más (alrededor de 2 minutos en un laptop con un Intel Core i5 4258U), pero una vez obtenidas todas las similitudes de todos los usuarios con todos los usuarios no es necesario volver a calcular ninguna similitud a menos que entren nuevos usuarios en el sistema.
		
		Cuando están calculadas todas las similitudes se realiza lo mismo que el método anterior.
	\end{itemize}
	
	\section{Análisis de redes sociales}
	
\end{document}